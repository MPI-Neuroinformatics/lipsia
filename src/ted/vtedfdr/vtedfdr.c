/*
** estimate false discovery rate based on histograms
** input histograms are generated by "vted"
**
** Ref: Lohmann et al (2016) PLoS One, 11(6):e0158185
**
** G.Lohmann, MPI-KYB, Jan 2015
*/
#include <viaio/VImage.h>
#include <viaio/Vlib.h>
#include <viaio/mu.h>
#include <viaio/option.h>

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_histogram.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_math.h>


#define SQR(x) ((x)*(x))
#define ABS(x) ((x) > 0 ? (x) : -(x))


gsl_histogram *ReadHistogram(VString filename)
{
  double fz=0,mx=0,lower,binsize=0;
  size_t i,nbins;
  
  FILE *fp=fopen(filename,"r");
  if (!fp) VError(" error reading file %f",filename);

  double zmin = 999999;
  double zmax = -999999;
  nbins = 0;
  while(!feof(fp)) {
    if (fscanf(fp, "%lf %lf %lf", &lower, &fz, &mx) != 3) break;
    if (lower < zmin) zmin = lower;
    if (lower > zmax) zmax = lower;
    nbins++;
  }

  binsize = (zmax-zmin)/(double)(nbins-1);
  zmax += binsize;
  gsl_histogram *hist = gsl_histogram_alloc(nbins);
  gsl_histogram_set_ranges_uniform (hist,zmin,zmax);

  rewind(fp);
  for (i=0; i<nbins; i++) {
    if (fscanf(fp, "%lf %lf %lf", &lower, &fz, &mx) != 3) break;
    hist->bin[i] = mx;
  }
  fclose(fp);
  return hist;
}



int main(int argc, char *argv[])
{
  static VString realfilename = "";
  static VString nullfilename = "";
  static VString outfilename = "";
  static VFloat  alpha = 0.05;
  static VOptionDescRec  options[] = {
    {"real",VStringRepn,1,(VPointer) &realfilename,VRequiredOpt,NULL,"input real histogram file"},
    {"null",VStringRepn,1,(VPointer) &nullfilename,VRequiredOpt,NULL,"input null histogram file"},
    {"out",VStringRepn,1,(VPointer) &outfilename,VRequiredOpt,NULL,"output txt file"},
    {"alpha",VFloatRepn,1,(VPointer) &alpha,VOptionalOpt,NULL,"alpha level"},
  };
  double lower=0,upper=0,tiny=1.0e-8;
  long i;
  VParseFilterCmd(VNumber(options),options,argc,argv,NULL,NULL);
  gsl_set_error_handler_off();


  /* read real histogram */
  gsl_histogram *realhist = ReadHistogram(realfilename);
  size_t nbins = gsl_histogram_bins(realhist);

  /* read null histogram */
  gsl_histogram *nullhist = ReadHistogram(nullfilename);
  if (nbins != gsl_histogram_bins(nullhist)) VError(" inconsistent histogram bins");


  /* cumulative distribution functions */
  gsl_histogram_pdf *cdfz = gsl_histogram_pdf_alloc(nbins);
  gsl_histogram_pdf *cdf0 = gsl_histogram_pdf_alloc(nbins);
  gsl_histogram_pdf_init (cdfz,realhist);
  gsl_histogram_pdf_init (cdf0,nullhist);


  FILE *fp = fopen(outfilename,"w");
  if (!fp) VError(" err opening file %s",outfilename);
  fprintf(fp,"#     ted            F0            Fz           FDR \n");
  fprintf(fp,"#------------------------------------------------------\n");


  /* tail-area FDR */
  double cutoff=0;
  int flag = 0;
  for (i=0; i<nbins; i++) {
    gsl_histogram_get_range (realhist,i,&lower,&upper);
    double z = lower + 0.5*(upper-lower);
    double Fz = 1.0-cdfz->sum[i];
    double F0 = 1.0-cdf0->sum[i];
    double Fdr = 0.0;
    if (Fz  > tiny) Fdr = F0/Fz;
    if (Fdr > 1.0) Fdr = 1.0;
    if (Fdr < 0.0) Fdr = 0.0;

    if (Fdr < alpha && flag == 0 && i > 10) {
      flag = 1;
      cutoff = z;
    }
    fprintf(fp," %12.8f  %12.8f  %12.8f  %12.8f\n",z,F0,Fz,Fdr);
  }
  fprintf(fp," Fdr < %.3f  if ted > %lf\n",alpha,cutoff);
  fprintf(stderr," Fdr < %.3f  if ted > %lf\n",alpha,cutoff);

  fclose(fp);
  exit(0);
}
