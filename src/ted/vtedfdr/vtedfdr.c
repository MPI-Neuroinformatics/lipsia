/*
** estimate false discovery rate based on histograms
** input histograms are generated by "vted"
**
** Ref: Lohmann et al (2016) PLoS One, 11(6):e0158185
**
** G.Lohmann, MPI-KYB, Jan 2015
*/
#include <viaio/VImage.h>
#include <viaio/Vlib.h>
#include <viaio/mu.h>
#include <viaio/option.h>

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_histogram.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_math.h>


#define SQR(x) ((x)*(x))
#define ABS(x) ((x) > 0 ? (x) : -(x))

#define HMIN 0
#define HMAX 1.001

#define NBINS 10000

size_t CountLines(FILE *fp)
{
  char ch;
  size_t numlines=0;
  while(!feof(fp)) {
    ch = fgetc(fp);
    if(ch == '\n') {
      numlines++;
    }
  }
  rewind(fp);
  return numlines;
}


void ReadTxtHist(char *filename,gsl_histogram *hist)
{
  FILE *fp=fopen(filename,"r");
  if (!fp) VError("err opening %s",filename);

  size_t nbins = CountLines(fp);
  if (nbins != (size_t)NBINS)
    VError(" inconsistent bins: %lu",gsl_histogram_bins (hist));

  size_t i=0;
  double lower=0,hz=0,mx=0;
  for (i=0; i<nbins; i++) {
    if (fscanf(fp,"%lf %lf %lf",&lower,&hz,&mx) != 3) VError(" read error");
    if (lower < HMIN || lower >= HMAX) VError(" value out of histogram range: %f",lower);
    hist->bin[i] = mx;
  }
  fclose(fp);
}



int main(int argc, char *argv[])
{
  static VString realfilename = "";
  static VString nullfilename = "";
  static VString outfilename = "";
  static VFloat  alpha = 0.05;
  static VOptionDescRec  options[] = {
    {"real",VStringRepn,1,(VPointer) &realfilename,VRequiredOpt,NULL,"input real histogram file"},
    {"null",VStringRepn,1,(VPointer) &nullfilename,VRequiredOpt,NULL,"input null histogram file"},
    {"out",VStringRepn,1,(VPointer) &outfilename,VRequiredOpt,NULL,"output txt file"},
    {"alpha",VFloatRepn,1,(VPointer) &alpha,VOptionalOpt,NULL,"alpha level"},
  };
  double lower=0,upper=0,tiny=1.0e-8;
  long i;
  VParseFilterCmd(VNumber(options),options,argc,argv,NULL,NULL);
  gsl_set_error_handler_off();


  /* ini histogram structs */
  size_t nbins = NBINS;
  double hmin = HMIN,hmax = HMAX;
  gsl_histogram *realhist = gsl_histogram_alloc (nbins);
  gsl_histogram_set_ranges_uniform (realhist,hmin,hmax);
  gsl_histogram *nullhist = gsl_histogram_alloc (nbins);
  gsl_histogram_set_ranges_uniform (nullhist,hmin,hmax);



  /* cumulative distribution functions */
  gsl_histogram_pdf *cdfz = gsl_histogram_pdf_alloc(nbins);
  gsl_histogram_pdf *cdf0 = gsl_histogram_pdf_alloc(nbins);
  gsl_histogram_pdf_init (cdfz,realhist);
  gsl_histogram_pdf_init (cdf0,nullhist);


  FILE *fp = fopen(outfilename,"w");
  if (!fp) VError(" err opening file %s",outfilename);
  fprintf(fp,"#     ted            F0            Fz           FDR \n");
  fprintf(fp,"#------------------------------------------------------\n");


  /* tail-area FDR */
  double cutoff=0;
  int flag = 0;
  for (i=0; i<nbins; i++) {
    gsl_histogram_get_range (realhist,i,&lower,&upper);
    double z = lower + 0.5*(upper-lower);
    double Fz = 1.0-cdfz->sum[i];
    double F0 = 1.0-cdf0->sum[i];
    double Fdr = 0.0;
    if (Fz  > tiny) Fdr = F0/Fz;
    if (Fdr > 1.0) Fdr = 1.0;
    if (Fdr < 0.0) Fdr = 0.0;

    if (Fdr < alpha && flag == 0 && i > 10) {
      flag = 1;
      cutoff = z;
    }
    fprintf(fp," %12.8f  %12.8f  %12.8f  %12.8f\n",z,F0,Fz,Fdr);
  }
  fprintf(fp," Fdr < %.3f  if ted > %lf\n",alpha,cutoff);
  fprintf(stderr," Fdr < %.3f  if ted > %lf\n",alpha,cutoff);

  fclose(fp);
  exit(0);
}
